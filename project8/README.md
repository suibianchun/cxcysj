**Project8: AES impl with ARM instruction**

由于本机是x86架构，对于本任务的完成，无法进行实际测试，主要是通过学习ARM NEON指令集中的指令，如：

vaeseq_u8 指令用于执行字节替代和轮密钥加操作。具体来说，vaeseq_u8 指令接受两个输入向量作为参数：一个是输入数据向量，另一个是轮密钥向量。它将这两个向量的对应元素进行字节替代操作，并将结果保存在输出向量中。字节替代操作使用了 AES 算法中的 S 盒进行替代；

vaesmcq_u8 指令用于执行轮函数中的 S 盒输出线性变换和轮内混淆操作。具体来说，vaesmcq_u8 指令接受一个输入向量作为参数，对该向量的每个元素执行 S 盒输出线性变换和轮内混淆操作，并将结果保存在输出向量中。这个操作是 AES 算法中的一个重要步骤，用于提高加密的混淆度和安全性。

**代码实现过程：**

这段代码最终实现了一个使用 AES-128 算法进行加密的函数 oqs_aes128_ecb_enc_sch_armv8。

首先，在 main 函数中定义了用于测试的明文 plaintext 和一个简单的示例密钥 key。然后，创建了一个长度为 plaintext_len 的数组 ciphertext 用于存储加密后的数据。

接下来，通过将密钥 key 复制到 aes128ctx 结构体变量 ctx 的字段 sk_exp 中，初始化了加密所需的上下文信息。

在 oqs_aes128_ecb_enc_sch_armv8 函数中，使用 aes128ctx 结构体变量 ctx 和明文数据对每个 16 字节的分组数据进行加密。通过调用 oqs_aes128_enc_sch_block_armv8 函数实现了 ECB 模式的 AES 加密，该函数会将一个 16 字节的明文块转换为对应的密文块。

最后，通过遍历打印函数，将明文和密文数据以十六进制的格式输出到控制台上。

**具体介绍一下核心函数：**

**static inline void aes128_armv8_encrypt**函数是一个使用 ARMv8 架构下硬件加速方式实现的 AES-128 加密函数。它接受 AES 轮密钥和待加密数据作为输入，并使用 ARMv8 指令集中的 AES 加密指令完成加密操作。该函数通过并行执行多个加密操作以提高加密速度，并将结果存储在输出指针指向的内存中；

**oqs_aes128_enc_sch_block_armv8**函数接受明文、密钥调度表以及密文缓冲区作为输入参数。
该函数首先将传入的 _schedule 指针转换为 unsigned char* 类型，并存储在名为 schedule 的临时变量中。这是因为 aes128_armv8_encrypt 函数要求轮密钥为 unsigned char* 类型。

接下来，该函数调用 aes128_armv8_encrypt 函数，将 schedule、plaintext 和 ciphertext 作为参数传递给它。这样就完成了对明文的 AES-128 加密操作，并将结果存储在 ciphertext 缓冲区中。

总体来说，这个函数是一个简单的封装函数，通过调用 aes128_armv8_encrypt 函数来完成 AES-128 加密操作。它提供了一个方便的接口，使得在 ARMv8 架构下进行 AES-128 加密更加容易和高效。

**oqs_aes128_ecb_enc_sch_armv8**函数接受明文、明文长度、密钥调度表以及密文缓冲区作为输入参数。
首先，函数使用assert验证明文长度必须是 16 的倍数，以确保输入的明文长度符合 AES-128 的要求。
接着，函数将传入的 schedule 指针转换为 aes128ctx* 类型，并存储在名为 ctx 的临时变量中。aes128ctx 结构体包含了 AES-128 的轮密钥扩展表。

然后，函数通过一个循环遍历明文分块，每个块大小为 16 字节。在每个迭代中，函数调用 oqs_aes128_enc_sch_block_armv8 函数，将当前迭代的明文块、轮密钥扩展表和对应的密文块作为参数传递给它。这样就完成了对每个块的 AES-128 加密操作，并将结果存储在对应的密文块中。

总体来说，这个函数实现了基于 ARMv8 架构下硬件加速的 AES-128 ECB 模式加密。它通过调用 oqs_aes128_enc_sch_block_armv8 函数，对每个明文块进行加密，并将加密结果存储在对应的密文块中。这样就可以对整个明文进行分块加密的操作，并输出最终的密文结果。



